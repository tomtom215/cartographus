// Cartographus - Media Server Analytics and Geographic Visualization
// Copyright 2026 Tom F. (tomtom215)
// SPDX-License-Identifier: AGPL-3.0-or-later
// https://github.com/tomtom215/cartographus

// Package tautulli_seed provides test infrastructure for generating seeded Tautulli databases.
//
// Run with: go test -v -run TestGenerateSeedDatabase ./testdata/tautulli/
//
// STATIC CURATED DATASET (v2.0)
// =============================
// This generates seed.db using the static_seed_data.sql file which contains:
//   - 550 deterministic records with ZERO randomness
//   - 10 fixed users (55 records each)
//   - 220 movies (IDs 1-220), 275 episodes (IDs 221-495), 55 tracks (IDs 496-550)
//   - Session keys in format 'static-session-XXXX' for end-to-end tracing
//   - Date range: June 1, 2025 - December 15, 2025
//
// CRITICAL PROPERTIES:
//   - 100% deterministic: Identical output every time
//   - 100% auditable: Every record traceable by ID
//   - Session key format enables pipeline debugging
//
// The static SQL file is generated by: python3 generate_static_data.py > static_seed_data.sql

package tautulli_seed

import (
	"bufio"
	"context"
	"crypto/sha256"
	"database/sql"
	"encoding/hex"
	"fmt"
	"math/rand"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"testing"
	"time"

	// DuckDB driver - uses sqlite_scanner extension to create SQLite databases
	_ "github.com/duckdb/duckdb-go/v2"
)

// Configuration for seed data generation
const (
	seedDBName      = "seed.db"
	staticSQLFile   = "static_seed_data.sql"
	numUsers        = 10
	numSessions     = 550 // Exactly 550 deterministic records
	numMovies       = 220 // 40% - IDs 1-220
	numEpisodes     = 275 // 50% - IDs 221-495
	numTracks       = 55  // 10% - IDs 496-550
	numTVShows      = 20  // Legacy - kept for backward compat
	numMusicArtists = 15  // Legacy - kept for backward compat
	monthsOfHistory = 6
)

var rng *rand.Rand

// Video quality options
var (
	videoResolutions   = []string{"480", "720", "1080", "2160"}
	videoCodecs        = []string{"h264", "hevc", "mpeg4", "vp9"}
	audioCodecs        = []string{"aac", "ac3", "dts", "eac3", "truehd"}
	audioChannels      = []string{"2", "6", "8"}
	containers         = []string{"mkv", "mp4", "avi", "m4v"}
	transcodeDecisions = []string{"direct play", "transcode", "copy"}
	locationTypes      = []string{"lan", "wan"}
)

// User represents a Tautulli user with viewing preferences
type User struct {
	ID            int
	Username      string
	FriendlyName  string
	IPAddress     string
	City          string
	Country       string
	Platform      string
	Player        string
	Product       string
	MachineID     string
	MovieWeight   float64
	TVWeight      float64
	MusicWeight   float64
	WatchHourBias int
}

// Movie represents a movie in the library
type Movie struct {
	RatingKey     string
	Title         string
	Year          int
	Studio        string
	ContentRating string
	Genres        string
	Directors     string
	Actors        string
	Duration      int
	Thumb         string
	GUID          string
}

// TVShow represents a TV show with episodes
type TVShow struct {
	GrandparentRatingKey string
	GrandparentTitle     string
	Seasons              []TVSeason
	ContentRating        string
	Genres               string
	Studio               string
	Thumb                string
	GUID                 string
}

// TVSeason represents a season of a TV show
type TVSeason struct {
	ParentRatingKey string
	SeasonNumber    int
	Episodes        []TVEpisode
}

// TVEpisode represents an episode
type TVEpisode struct {
	RatingKey     string
	Title         string
	EpisodeNumber int
	Duration      int
}

// MusicArtist represents a music artist with albums
type MusicArtist struct {
	GrandparentRatingKey string
	ArtistName           string
	Albums               []MusicAlbum
}

// MusicAlbum represents an album
type MusicAlbum struct {
	ParentRatingKey string
	AlbumTitle      string
	Tracks          []MusicTrack
}

// MusicTrack represents a track
type MusicTrack struct {
	RatingKey string
	Title     string
	Duration  int
}

type sessionData struct {
	started               int64
	stopped               int64
	ratingKey             string
	parentRatingKey       *string
	grandparentRatingKey  *string
	mediaType             string
	title                 string
	parentTitle           *string
	grandparentTitle      *string
	fullTitle             string
	mediaIndex            *int
	parentMediaIndex      *int
	sectionID             int
	libraryName           string
	thumb                 string
	parentThumb           *string
	grandparentThumb      *string
	year                  int
	contentRating         string
	duration              int
	guid                  string
	directors             *string
	writers               *string
	actors                *string
	genres                string
	studio                string
	bandwidth             int
	location              string
	sessionKey            string
	viewOffset            int
	percentComplete       int
	pausedCounter         int
	transcodeDecision     string
	videoCodec            string
	videoBitrate          int
	videoResolution       string
	videoFullResolution   string
	audioCodec            string
	audioChannels         string
	container             string
	bitrate               int
	videoDecision         string
	audioDecision         string
	subtitleDecision      *string
	streamBitrate         int
	streamVideoCodec      string
	streamVideoResolution string
	streamAudioCodec      string
	streamAudioChannels   string
}

// TestGenerateSeedDatabase generates the seed.db file for Tautulli container testing.
// Run with: go test -v -run TestGenerateSeedDatabase ./testdata/tautulli/
//
// This function uses the static_seed_data.sql file which contains 550 deterministic
// records with traceable session keys in the format 'static-session-XXXX'.
func TestGenerateSeedDatabase(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping seed database generation in short mode")
	}

	// Get the directory of this test file
	_, filename, _, ok := runtime.Caller(0)
	if !ok {
		t.Fatal("Failed to get current file path")
	}
	dir := filepath.Dir(filename)
	dbPath := filepath.Join(dir, seedDBName)
	sqlPath := filepath.Join(dir, staticSQLFile)

	// Check if static SQL file exists
	if _, err := os.Stat(sqlPath); os.IsNotExist(err) {
		t.Fatalf("Static SQL file not found: %s\nRun: python3 generate_static_data.py > static_seed_data.sql", sqlPath)
	}

	// Remove existing database
	if err := os.Remove(dbPath); err != nil && !os.IsNotExist(err) {
		t.Fatalf("Failed to remove existing database: %v", err)
	}

	// Create DuckDB connection
	db, err := sql.Open("duckdb", "")
	if err != nil {
		t.Fatalf("Failed to open DuckDB: %v", err)
	}
	defer db.Close()

	ctx := context.Background()

	// Load the sqlite_scanner extension (should be pre-installed via setup-duckdb-extensions.sh)
	// Try LOAD first (works if extension is already installed), then try INSTALL if needed
	t.Log("Loading sqlite_scanner extension...")
	if _, err := db.ExecContext(ctx, "LOAD sqlite_scanner;"); err != nil {
		t.Log("LOAD failed, attempting INSTALL...")
		if _, installErr := db.ExecContext(ctx, "INSTALL sqlite_scanner;"); installErr != nil {
			t.Fatalf("Failed to install sqlite_scanner: %v (original LOAD error: %v)", installErr, err)
		}
		if _, err := db.ExecContext(ctx, "LOAD sqlite_scanner;"); err != nil {
			t.Fatalf("Failed to load sqlite_scanner after install: %v", err)
		}
	}

	// Attach SQLite database
	t.Logf("Creating SQLite database: %s", dbPath)
	attachQuery := fmt.Sprintf("ATTACH '%s' AS tautulli (TYPE SQLITE)", dbPath)
	if _, err := db.ExecContext(ctx, attachQuery); err != nil {
		t.Fatalf("Failed to attach SQLite database: %v", err)
	}
	defer db.ExecContext(ctx, "DETACH tautulli") //nolint:errcheck

	t.Log("Creating Tautulli database schema...")
	if err := createSchema(ctx, db); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}

	// Load and execute static SQL file
	t.Logf("Loading static SQL data from: %s", sqlPath)
	sessionCount, err := loadStaticSQL(ctx, t, db, sqlPath)
	if err != nil {
		t.Fatalf("Failed to load static SQL: %v", err)
	}

	t.Logf("Successfully created %s with %d sessions", dbPath, sessionCount)

	// Verify the database
	verifyDatabase(t, ctx, db, sessionCount)
}

// loadStaticSQL reads and executes SQL statements from the static seed data file
func loadStaticSQL(ctx context.Context, t *testing.T, db *sql.DB, sqlPath string) (int, error) {
	file, err := os.Open(sqlPath)
	if err != nil {
		return 0, fmt.Errorf("open SQL file: %w", err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	// Increase buffer size for long SQL lines
	buf := make([]byte, 0, 64*1024)
	scanner.Buffer(buf, 1024*1024)

	insertCount := 0
	sessionHistoryCount := 0
	lineNum := 0

	for scanner.Scan() {
		lineNum++
		line := strings.TrimSpace(scanner.Text())

		// Skip empty lines and comments
		if line == "" || strings.HasPrefix(line, "--") {
			continue
		}

		// Execute INSERT statements
		if strings.HasPrefix(line, "INSERT INTO") {
			// Prefix table names with 'tautulli.' for attached database
			stmt := strings.Replace(line, "INSERT INTO users", "INSERT INTO tautulli.users", 1)
			stmt = strings.Replace(stmt, "INSERT INTO session_history_metadata", "INSERT INTO tautulli.session_history_metadata", 1)
			stmt = strings.Replace(stmt, "INSERT INTO session_history_media_info", "INSERT INTO tautulli.session_history_media_info", 1)
			stmt = strings.Replace(stmt, "INSERT INTO session_history", "INSERT INTO tautulli.session_history", 1)

			if _, err := db.ExecContext(ctx, stmt); err != nil {
				return 0, fmt.Errorf("execute line %d: %w\nSQL: %s", lineNum, err, stmt[:min(200, len(stmt))])
			}

			insertCount++
			if strings.Contains(stmt, "INSERT INTO tautulli.session_history (") {
				sessionHistoryCount++
			}

			// Log progress every 100 inserts
			if insertCount%100 == 0 {
				t.Logf("Executed %d INSERT statements (%d session_history)...", insertCount, sessionHistoryCount)
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return 0, fmt.Errorf("scan SQL file: %w", err)
	}

	t.Logf("Executed %d total INSERT statements (%d session_history records)", insertCount, sessionHistoryCount)
	return sessionHistoryCount, nil
}

// TestGenerateSeedDatabaseLegacy is the legacy function that generates random data
// Kept for backward compatibility - use TestGenerateSeedDatabase for deterministic data
func TestGenerateSeedDatabaseLegacy(t *testing.T) {
	t.Skip("Skipping legacy random generator - use TestGenerateSeedDatabase for deterministic static data")

	// Initialize deterministic random source for reproducible data
	rng = rand.New(rand.NewSource(42))

	// Get the directory of this test file
	_, filename, _, ok := runtime.Caller(0)
	if !ok {
		t.Fatal("Failed to get current file path")
	}
	dir := filepath.Dir(filename)
	dbPath := filepath.Join(dir, "seed_legacy.db")

	// Remove existing database
	if err := os.Remove(dbPath); err != nil && !os.IsNotExist(err) {
		t.Fatalf("Failed to remove existing database: %v", err)
	}

	// Create DuckDB connection
	db, err := sql.Open("duckdb", "")
	if err != nil {
		t.Fatalf("Failed to open DuckDB: %v", err)
	}
	defer db.Close()

	ctx := context.Background()

	// Load the sqlite_scanner extension
	t.Log("Loading sqlite_scanner extension...")
	if _, err := db.ExecContext(ctx, "LOAD sqlite_scanner;"); err != nil {
		t.Log("LOAD failed, attempting INSTALL...")
		if _, installErr := db.ExecContext(ctx, "INSTALL sqlite_scanner;"); installErr != nil {
			t.Fatalf("Failed to install sqlite_scanner: %v (original LOAD error: %v)", installErr, err)
		}
		if _, err := db.ExecContext(ctx, "LOAD sqlite_scanner;"); err != nil {
			t.Fatalf("Failed to load sqlite_scanner after install: %v", err)
		}
	}

	// Attach SQLite database
	t.Logf("Creating SQLite database: %s", dbPath)
	attachQuery := fmt.Sprintf("ATTACH '%s' AS tautulli (TYPE SQLITE)", dbPath)
	if _, err := db.ExecContext(ctx, attachQuery); err != nil {
		t.Fatalf("Failed to attach SQLite database: %v", err)
	}
	defer db.ExecContext(ctx, "DETACH tautulli") //nolint:errcheck

	t.Log("Creating Tautulli database schema...")
	if err := createSchema(ctx, db); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}

	t.Log("Generating test data...")
	users := generateUsers()
	movies := generateMovies()
	tvShows := generateTVShows()
	musicArtists := generateMusicArtists()

	t.Logf("Generated %d users, %d movies, %d TV shows, %d music artists",
		len(users), len(movies), len(tvShows), len(musicArtists))

	t.Log("Inserting users...")
	if err := insertUsers(ctx, db, users); err != nil {
		t.Fatalf("Failed to insert users: %v", err)
	}

	t.Log("Inserting session history...")
	sessionCount, err := insertSessions(ctx, t, db, users, movies, tvShows, musicArtists)
	if err != nil {
		t.Fatalf("Failed to insert sessions: %v", err)
	}

	t.Logf("Successfully created %s with %d sessions", dbPath, sessionCount)

	// Verify the database
	verifyDatabase(t, ctx, db, sessionCount)
}

func createSchema(ctx context.Context, db *sql.DB) error {
	statements := []string{
		// Tautulli users table - required for API to work properly
		`CREATE TABLE IF NOT EXISTS tautulli.users (
			id INTEGER PRIMARY KEY,
			user_id INTEGER UNIQUE,
			username TEXT,
			friendly_name TEXT,
			thumb TEXT,
			custom_avatar_url TEXT,
			email TEXT,
			is_active INTEGER DEFAULT 1,
			is_admin INTEGER DEFAULT 0,
			is_home_user INTEGER DEFAULT 0,
			is_allow_sync INTEGER DEFAULT 0,
			is_restricted INTEGER DEFAULT 0,
			do_notify INTEGER DEFAULT 1,
			keep_history INTEGER DEFAULT 1,
			deleted_user INTEGER DEFAULT 0,
			allow_guest INTEGER DEFAULT 0,
			user_token TEXT,
			server_token TEXT,
			shared_libraries TEXT,
			filter_all TEXT,
			filter_movies TEXT,
			filter_tv TEXT,
			filter_music TEXT,
			filter_photos TEXT
		)`,
		`CREATE TABLE IF NOT EXISTS tautulli.session_history (
			id INTEGER PRIMARY KEY,
			reference_id INTEGER,
			date INTEGER NOT NULL,
			started INTEGER NOT NULL,
			stopped INTEGER,
			rating_key INTEGER,
			parent_rating_key INTEGER,
			grandparent_rating_key INTEGER,
			media_type TEXT,
			user_id INTEGER NOT NULL,
			user TEXT NOT NULL,
			friendly_name TEXT,
			ip_address TEXT,
			platform TEXT,
			player TEXT,
			product TEXT,
			machine_id TEXT,
			bandwidth INTEGER,
			location TEXT,
			quality_profile TEXT,
			session_key TEXT NOT NULL,
			view_offset INTEGER DEFAULT 0,
			percent_complete INTEGER DEFAULT 0,
			paused_counter INTEGER DEFAULT 0,
			transcode_decision TEXT,
			geo_city TEXT,
			geo_region TEXT,
			geo_country TEXT,
			geo_code TEXT,
			geo_latitude REAL,
			geo_longitude REAL,
			relayed INTEGER DEFAULT 0,
			secure INTEGER DEFAULT 1,
			live INTEGER DEFAULT 0
		)`,
		`CREATE TABLE IF NOT EXISTS tautulli.session_history_metadata (
			id INTEGER PRIMARY KEY,
			rating_key INTEGER,
			parent_rating_key INTEGER,
			grandparent_rating_key INTEGER,
			title TEXT,
			parent_title TEXT,
			grandparent_title TEXT,
			original_title TEXT,
			full_title TEXT,
			media_index INTEGER,
			parent_media_index INTEGER,
			section_id INTEGER,
			library_name TEXT,
			thumb TEXT,
			parent_thumb TEXT,
			grandparent_thumb TEXT,
			art TEXT,
			media_type TEXT,
			year INTEGER,
			originally_available_at TEXT,
			added_at INTEGER,
			updated_at INTEGER,
			last_viewed_at INTEGER,
			content_rating TEXT,
			summary TEXT,
			tagline TEXT,
			rating REAL,
			duration INTEGER,
			guid TEXT,
			directors TEXT,
			writers TEXT,
			actors TEXT,
			genres TEXT,
			studio TEXT,
			labels TEXT
		)`,
		`CREATE TABLE IF NOT EXISTS tautulli.session_history_media_info (
			id INTEGER PRIMARY KEY,
			video_codec TEXT,
			video_codec_level TEXT,
			video_bitrate INTEGER,
			video_bit_depth INTEGER,
			video_resolution TEXT,
			video_full_resolution TEXT,
			audio_codec TEXT,
			audio_bitrate INTEGER,
			audio_channels INTEGER,
			container TEXT,
			bitrate INTEGER,
			transcode_decision TEXT,
			video_decision TEXT,
			audio_decision TEXT,
			subtitle_decision TEXT,
			stream_bitrate INTEGER,
			stream_video_codec TEXT,
			stream_video_resolution TEXT,
			stream_audio_codec TEXT,
			stream_audio_channels TEXT
		)`,
	}

	for i, stmt := range statements {
		if _, err := db.ExecContext(ctx, stmt); err != nil {
			return fmt.Errorf("execute statement %d: %w", i, err)
		}
	}

	return nil
}

func generateUsers() []User {
	return []User{
		{ID: 1, Username: "admin", FriendlyName: "Admin User", IPAddress: "192.168.1.100", City: "New York", Country: "US", Platform: "Chrome", Player: "Plex Web", Product: "Plex Web", MachineID: generateMachineID("admin"), MovieWeight: 0.4, TVWeight: 0.5, MusicWeight: 0.1, WatchHourBias: 20},
		{ID: 2, Username: "moviebuff", FriendlyName: "Movie Buff", IPAddress: "73.45.123.89", City: "Los Angeles", Country: "US", Platform: "Roku", Player: "Plex for Roku", Product: "Plex for Roku", MachineID: generateMachineID("moviebuff"), MovieWeight: 0.8, TVWeight: 0.15, MusicWeight: 0.05, WatchHourBias: 21},
		{ID: 3, Username: "tvaddict", FriendlyName: "TV Addict", IPAddress: "98.234.56.78", City: "Chicago", Country: "US", Platform: "Android", Player: "Plex for Android (TV)", Product: "Plex for Android (TV)", MachineID: generateMachineID("tvaddict"), MovieWeight: 0.1, TVWeight: 0.85, MusicWeight: 0.05, WatchHourBias: 19},
		{ID: 4, Username: "musiclover", FriendlyName: "Music Lover", IPAddress: "82.132.45.67", City: "London", Country: "UK", Platform: "iOS", Player: "Plex for iOS", Product: "Plex for iOS", MachineID: generateMachineID("musiclover"), MovieWeight: 0.1, TVWeight: 0.1, MusicWeight: 0.8, WatchHourBias: 8},
		{ID: 5, Username: "familyaccount", FriendlyName: "Family Account", IPAddress: "176.89.234.12", City: "Berlin", Country: "DE", Platform: "Samsung", Player: "Plex for Samsung", Product: "Plex for Samsung", MachineID: generateMachineID("familyaccount"), MovieWeight: 0.35, TVWeight: 0.55, MusicWeight: 0.1, WatchHourBias: 18},
		{ID: 6, Username: "nightowl", FriendlyName: "Night Owl", IPAddress: "45.67.89.123", City: "Tokyo", Country: "JP", Platform: "Apple TV", Player: "Plex for Apple TV", Product: "Plex for Apple TV", MachineID: generateMachineID("nightowl"), MovieWeight: 0.5, TVWeight: 0.4, MusicWeight: 0.1, WatchHourBias: 23},
		{ID: 7, Username: "casualviewer", FriendlyName: "Casual Viewer", IPAddress: "203.45.67.89", City: "Sydney", Country: "AU", Platform: "Firefox", Player: "Plex Web", Product: "Plex Web", MachineID: generateMachineID("casualviewer"), MovieWeight: 0.33, TVWeight: 0.34, MusicWeight: 0.33, WatchHourBias: 12},
		{ID: 8, Username: "mobilewatcher", FriendlyName: "Mobile Watcher", IPAddress: "156.78.90.234", City: "Toronto", Country: "CA", Platform: "Android", Player: "Plex for Android (Mobile)", Product: "Plex for Android", MachineID: generateMachineID("mobilewatcher"), MovieWeight: 0.3, TVWeight: 0.6, MusicWeight: 0.1, WatchHourBias: 7},
		{ID: 9, Username: "weekendwarrior", FriendlyName: "Weekend Warrior", IPAddress: "89.123.45.67", City: "Paris", Country: "FR", Platform: "PlayStation", Player: "Plex for PlayStation", Product: "Plex for PlayStation", MachineID: generateMachineID("weekendwarrior"), MovieWeight: 0.6, TVWeight: 0.35, MusicWeight: 0.05, WatchHourBias: 14},
		{ID: 10, Username: "bingewatcher", FriendlyName: "Binge Watcher", IPAddress: "112.45.78.90", City: "Singapore", Country: "SG", Platform: "Xbox", Player: "Plex for Xbox", Product: "Plex for Xbox", MachineID: generateMachineID("bingewatcher"), MovieWeight: 0.2, TVWeight: 0.75, MusicWeight: 0.05, WatchHourBias: 22},
	}
}

func generateMachineID(seed string) string {
	hash := sha256.Sum256([]byte(seed + "-machine-id"))
	return hex.EncodeToString(hash[:])[:32]
}

func generateMovies() []Movie {
	titles := []string{
		"The Matrix", "Inception", "Interstellar", "The Dark Knight", "Pulp Fiction",
		"Fight Club", "Forrest Gump", "The Shawshank Redemption", "Goodfellas", "The Godfather",
		"Jurassic Park", "Titanic", "Avatar", "The Avengers", "Iron Man",
		"Spider-Man", "Batman Begins", "Wonder Woman", "Black Panther", "Guardians of the Galaxy",
		"Star Wars", "The Lord of the Rings", "Harry Potter", "Back to the Future", "E.T.",
		"Jaws", "Raiders of the Lost Ark", "Die Hard", "Terminator 2", "Alien",
		"Blade Runner", "The Silence of the Lambs", "Se7en", "Gladiator", "Braveheart",
		"The Lion King", "Finding Nemo", "Toy Story", "Up", "WALL-E",
		"Coco", "Inside Out", "Frozen", "Moana", "Encanto",
		"Dune", "No Time to Die", "Top Gun: Maverick", "Everything Everywhere All at Once", "Oppenheimer",
	}

	studios := []string{"Warner Bros", "Universal", "Paramount", "Disney", "Sony", "MGM", "Lionsgate", "A24"}
	ratings := []string{"G", "PG", "PG-13", "R", "NR"}
	genres := []string{"Action", "Drama", "Comedy", "Sci-Fi", "Horror", "Thriller", "Adventure", "Animation"}

	movies := make([]Movie, numMovies)
	for i := 0; i < numMovies; i++ {
		ratingKey := fmt.Sprintf("%d", 1000+i)
		movies[i] = Movie{
			RatingKey:     ratingKey,
			Title:         titles[i%len(titles)],
			Year:          2010 + rng.Intn(14),
			Studio:        studios[rng.Intn(len(studios))],
			ContentRating: ratings[rng.Intn(len(ratings))],
			Genres:        genres[rng.Intn(len(genres))] + "|" + genres[rng.Intn(len(genres))],
			Directors:     fmt.Sprintf("Director %d", rng.Intn(50)),
			Actors:        fmt.Sprintf("Actor %d|Actor %d|Actor %d", rng.Intn(100), rng.Intn(100), rng.Intn(100)),
			Duration:      90 + rng.Intn(90),
			Thumb:         fmt.Sprintf("/library/metadata/%s/thumb", ratingKey),
			GUID:          fmt.Sprintf("plex://movie/%s", generateGUID(ratingKey)),
		}
	}
	return movies
}

func generateTVShows() []TVShow {
	showTitles := []string{
		"Breaking Bad", "Game of Thrones", "The Office", "Friends", "Stranger Things",
		"The Mandalorian", "The Crown", "Succession", "Ted Lasso", "House of the Dragon",
		"The Last of Us", "Severance", "The Bear", "Only Murders in the Building", "Yellowjackets",
		"Better Call Saul", "Euphoria", "The White Lotus", "Wednesday", "Andor",
	}

	shows := make([]TVShow, numTVShows)
	for i := 0; i < numTVShows; i++ {
		grandparentKey := fmt.Sprintf("%d", 2000+i)
		numSeasons := 2 + rng.Intn(6)

		seasons := make([]TVSeason, numSeasons)
		for s := 0; s < numSeasons; s++ {
			parentKey := fmt.Sprintf("%d", 3000+i*10+s)
			numEpisodes := 8 + rng.Intn(15)

			episodes := make([]TVEpisode, numEpisodes)
			for e := 0; e < numEpisodes; e++ {
				episodes[e] = TVEpisode{
					RatingKey:     fmt.Sprintf("%d", 4000+i*100+s*10+e),
					Title:         fmt.Sprintf("Episode %d", e+1),
					EpisodeNumber: e + 1,
					Duration:      25 + rng.Intn(40),
				}
			}

			seasons[s] = TVSeason{
				ParentRatingKey: parentKey,
				SeasonNumber:    s + 1,
				Episodes:        episodes,
			}
		}

		shows[i] = TVShow{
			GrandparentRatingKey: grandparentKey,
			GrandparentTitle:     showTitles[i%len(showTitles)],
			Seasons:              seasons,
			ContentRating:        []string{"TV-PG", "TV-14", "TV-MA"}[rng.Intn(3)],
			Genres:               "Drama|" + []string{"Comedy", "Thriller", "Sci-Fi", "Fantasy"}[rng.Intn(4)],
			Studio:               []string{"HBO", "Netflix", "AMC", "Apple TV+", "Disney+"}[rng.Intn(5)],
			Thumb:                fmt.Sprintf("/library/metadata/%s/thumb", grandparentKey),
			GUID:                 fmt.Sprintf("plex://show/%s", generateGUID(grandparentKey)),
		}
	}
	return shows
}

func generateMusicArtists() []MusicArtist {
	artistNames := []string{
		"The Beatles", "Pink Floyd", "Led Zeppelin", "Queen", "David Bowie",
		"Radiohead", "Nirvana", "The Rolling Stones", "Fleetwood Mac", "Eagles",
		"Taylor Swift", "Adele", "Ed Sheeran", "Coldplay", "Imagine Dragons",
	}

	artists := make([]MusicArtist, numMusicArtists)
	for i := 0; i < numMusicArtists; i++ {
		grandparentKey := fmt.Sprintf("%d", 5000+i)
		numAlbums := 3 + rng.Intn(8)

		albums := make([]MusicAlbum, numAlbums)
		for a := 0; a < numAlbums; a++ {
			parentKey := fmt.Sprintf("%d", 6000+i*10+a)
			numTracks := 8 + rng.Intn(8)

			tracks := make([]MusicTrack, numTracks)
			for t := 0; t < numTracks; t++ {
				tracks[t] = MusicTrack{
					RatingKey: fmt.Sprintf("%d", 7000+i*100+a*10+t),
					Title:     fmt.Sprintf("Track %d", t+1),
					Duration:  180 + rng.Intn(180),
				}
			}

			albums[a] = MusicAlbum{
				ParentRatingKey: parentKey,
				AlbumTitle:      fmt.Sprintf("Album %d", a+1),
				Tracks:          tracks,
			}
		}

		artists[i] = MusicArtist{
			GrandparentRatingKey: grandparentKey,
			ArtistName:           artistNames[i%len(artistNames)],
			Albums:               albums,
		}
	}
	return artists
}

func generateGUID(key string) string {
	hash := sha256.Sum256([]byte(key))
	return hex.EncodeToString(hash[:])[:24]
}

func insertUsers(ctx context.Context, db *sql.DB, users []User) error {
	for _, user := range users {
		_, err := db.ExecContext(ctx, `
			INSERT INTO tautulli.users (
				id, user_id, username, friendly_name, thumb, email,
				is_active, is_admin, is_home_user, is_allow_sync,
				is_restricted, do_notify, keep_history, deleted_user
			) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
		`,
			user.ID, user.ID, user.Username, user.FriendlyName,
			fmt.Sprintf("/library/users/%d/thumb", user.ID),
			fmt.Sprintf("%s@example.com", user.Username),
			1, // is_active
			0, // is_admin (first user could be admin)
			0, // is_home_user
			0, // is_allow_sync
			0, // is_restricted
			1, // do_notify
			1, // keep_history
			0, // deleted_user
		)
		if err != nil {
			return fmt.Errorf("insert user %s: %w", user.Username, err)
		}
	}
	return nil
}

func insertSessions(ctx context.Context, t *testing.T, db *sql.DB, users []User, movies []Movie, tvShows []TVShow, musicArtists []MusicArtist) (int, error) {
	endTime := time.Now().UTC()
	startTime := endTime.AddDate(0, -monthsOfHistory, 0)

	sessionCount := 0
	timeRange := endTime.Sub(startTime)
	var nextID int64 = 1

	for sessionCount < numSessions {
		user := users[rng.Intn(len(users))]

		randomOffset := time.Duration(rng.Int63n(int64(timeRange)))
		sessionTime := startTime.Add(randomOffset)

		hour := sessionTime.Hour()
		preferredHour := user.WatchHourBias
		if rng.Float64() > 0.3 {
			hourDiff := preferredHour - hour
			if hourDiff != 0 {
				adjustment := hourDiff / 2
				if adjustment == 0 {
					adjustment = hourDiff
				}
				sessionTime = sessionTime.Add(time.Duration(adjustment) * time.Hour)
			}
		}

		contentRoll := rng.Float64()
		var mediaType string
		if contentRoll < user.MovieWeight {
			mediaType = "movie"
		} else if contentRoll < user.MovieWeight+user.TVWeight {
			mediaType = "episode"
		} else {
			mediaType = "track"
		}

		var sd sessionData
		switch mediaType {
		case "movie":
			sd = generateMovieSession(movies, user, sessionTime)
		case "episode":
			sd = generateEpisodeSession(tvShows, user, sessionTime)
		case "track":
			sd = generateTrackSession(musicArtists, user, sessionTime)
		}

		sessionID := nextID
		nextID++

		// Insert session history
		// Note: 'reference_id' = sessionID ensures each record is unique (prevents grouping in Tautulli)
		// Note: 'date' column is set to 'started' value - Tautulli uses this for history filtering
		_, err := db.ExecContext(ctx, `
			INSERT INTO tautulli.session_history (
				id, reference_id, date, started, stopped, rating_key, parent_rating_key, grandparent_rating_key,
				media_type, user_id, user, friendly_name, ip_address, platform, player,
				product, machine_id, bandwidth, location, session_key, view_offset,
				percent_complete, paused_counter, transcode_decision, geo_city, geo_country
			) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
		`,
			sessionID, sessionID, sd.started, sd.started, sd.stopped,
			sd.ratingKey, sd.parentRatingKey, sd.grandparentRatingKey,
			sd.mediaType, user.ID, user.Username, user.FriendlyName,
			user.IPAddress, user.Platform, user.Player, user.Product, user.MachineID,
			sd.bandwidth, sd.location, sd.sessionKey,
			sd.viewOffset, sd.percentComplete, sd.pausedCounter,
			sd.transcodeDecision, user.City, user.Country,
		)
		if err != nil {
			return 0, fmt.Errorf("insert session history %d: %w", sessionID, err)
		}

		// Insert metadata
		_, err = db.ExecContext(ctx, `
			INSERT INTO tautulli.session_history_metadata (
				id, rating_key, parent_rating_key, grandparent_rating_key,
				title, parent_title, grandparent_title, full_title, media_index,
				parent_media_index, section_id, library_name, thumb, parent_thumb,
				grandparent_thumb, media_type, year, content_rating, duration, guid,
				directors, writers, actors, genres, studio
			) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
		`,
			sessionID, sd.ratingKey, sd.parentRatingKey, sd.grandparentRatingKey,
			sd.title, sd.parentTitle, sd.grandparentTitle, sd.fullTitle,
			sd.mediaIndex, sd.parentMediaIndex, sd.sectionID, sd.libraryName,
			sd.thumb, sd.parentThumb, sd.grandparentThumb, sd.mediaType,
			sd.year, sd.contentRating, sd.duration, sd.guid,
			sd.directors, sd.writers, sd.actors, sd.genres, sd.studio,
		)
		if err != nil {
			return 0, fmt.Errorf("insert metadata %d: %w", sessionID, err)
		}

		// Insert media info
		_, err = db.ExecContext(ctx, `
			INSERT INTO tautulli.session_history_media_info (
				id, video_codec, video_bitrate, video_resolution, video_full_resolution,
				audio_codec, audio_channels, container, bitrate, transcode_decision,
				video_decision, audio_decision, subtitle_decision, stream_bitrate,
				stream_video_codec, stream_video_resolution, stream_audio_codec,
				stream_audio_channels
			) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
		`,
			sessionID, sd.videoCodec, sd.videoBitrate, sd.videoResolution,
			sd.videoFullResolution, sd.audioCodec, sd.audioChannels,
			sd.container, sd.bitrate, sd.transcodeDecision,
			sd.videoDecision, sd.audioDecision, sd.subtitleDecision,
			sd.streamBitrate, sd.streamVideoCodec, sd.streamVideoResolution,
			sd.streamAudioCodec, sd.streamAudioChannels,
		)
		if err != nil {
			return 0, fmt.Errorf("insert media info %d: %w", sessionID, err)
		}

		sessionCount++

		if sessionCount%100 == 0 {
			t.Logf("Inserted %d/%d sessions...", sessionCount, numSessions)
		}
	}

	return sessionCount, nil
}

func generateMovieSession(movies []Movie, user User, sessionTime time.Time) sessionData {
	movie := movies[rng.Intn(len(movies))]

	durationMinutes := movie.Duration
	watchedMinutes := rng.Intn(durationMinutes + 1)
	percentComplete := (watchedMinutes * 100) / durationMinutes
	if percentComplete > 100 {
		percentComplete = 100
	}

	transcodeDecision := transcodeDecisions[rng.Intn(len(transcodeDecisions))]
	videoRes := videoResolutions[rng.Intn(len(videoResolutions))]
	videoCodec := videoCodecs[rng.Intn(len(videoCodecs))]
	audioCodec := audioCodecs[rng.Intn(len(audioCodecs))]

	started := sessionTime.Unix()
	stopped := sessionTime.Add(time.Duration(watchedMinutes) * time.Minute).Unix()
	sessionKey := fmt.Sprintf("session-%s-%d", user.MachineID[:8], started)

	return sessionData{
		started:               started,
		stopped:               stopped,
		ratingKey:             movie.RatingKey,
		mediaType:             "movie",
		title:                 movie.Title,
		fullTitle:             movie.Title,
		sectionID:             1,
		libraryName:           "Movies",
		thumb:                 movie.Thumb,
		year:                  movie.Year,
		contentRating:         movie.ContentRating,
		duration:              durationMinutes * 60 * 1000,
		guid:                  movie.GUID,
		directors:             &movie.Directors,
		actors:                &movie.Actors,
		genres:                movie.Genres,
		studio:                movie.Studio,
		bandwidth:             5000 + rng.Intn(15000),
		location:              locationTypes[rng.Intn(len(locationTypes))],
		sessionKey:            sessionKey,
		viewOffset:            watchedMinutes * 60 * 1000,
		percentComplete:       percentComplete,
		pausedCounter:         rng.Intn(5),
		transcodeDecision:     transcodeDecision,
		videoCodec:            videoCodec,
		videoBitrate:          8000 + rng.Intn(20000),
		videoResolution:       videoRes,
		videoFullResolution:   videoRes + "p",
		audioCodec:            audioCodec,
		audioChannels:         audioChannels[rng.Intn(len(audioChannels))],
		container:             containers[rng.Intn(len(containers))],
		bitrate:               10000 + rng.Intn(30000),
		videoDecision:         transcodeDecision,
		audioDecision:         "direct play",
		streamBitrate:         8000 + rng.Intn(15000),
		streamVideoCodec:      videoCodec,
		streamVideoResolution: videoRes,
		streamAudioCodec:      audioCodec,
		streamAudioChannels:   audioChannels[rng.Intn(len(audioChannels))],
	}
}

func generateEpisodeSession(tvShows []TVShow, user User, sessionTime time.Time) sessionData {
	show := tvShows[rng.Intn(len(tvShows))]
	season := show.Seasons[rng.Intn(len(show.Seasons))]
	episode := season.Episodes[rng.Intn(len(season.Episodes))]

	durationMinutes := episode.Duration
	watchedMinutes := rng.Intn(durationMinutes + 1)
	percentComplete := (watchedMinutes * 100) / durationMinutes
	if percentComplete > 100 {
		percentComplete = 100
	}

	transcodeDecision := transcodeDecisions[rng.Intn(len(transcodeDecisions))]
	videoRes := videoResolutions[rng.Intn(len(videoResolutions))]
	videoCodec := videoCodecs[rng.Intn(len(videoCodecs))]
	audioCodec := audioCodecs[rng.Intn(len(audioCodecs))]

	started := sessionTime.Unix()
	stopped := sessionTime.Add(time.Duration(watchedMinutes) * time.Minute).Unix()
	sessionKey := fmt.Sprintf("session-%s-%d", user.MachineID[:8], started)

	parentTitle := fmt.Sprintf("Season %d", season.SeasonNumber)
	grandparentTitle := show.GrandparentTitle
	fullTitle := fmt.Sprintf("%s - S%02dE%02d - %s", show.GrandparentTitle, season.SeasonNumber, episode.EpisodeNumber, episode.Title)

	return sessionData{
		started:               started,
		stopped:               stopped,
		ratingKey:             episode.RatingKey,
		parentRatingKey:       &season.ParentRatingKey,
		grandparentRatingKey:  &show.GrandparentRatingKey,
		mediaType:             "episode",
		title:                 episode.Title,
		parentTitle:           &parentTitle,
		grandparentTitle:      &grandparentTitle,
		fullTitle:             fullTitle,
		mediaIndex:            &episode.EpisodeNumber,
		parentMediaIndex:      &season.SeasonNumber,
		sectionID:             2,
		libraryName:           "TV Shows",
		thumb:                 fmt.Sprintf("/library/metadata/%s/thumb", episode.RatingKey),
		parentThumb:           &show.Thumb,
		grandparentThumb:      &show.Thumb,
		year:                  2020 + rng.Intn(4),
		contentRating:         show.ContentRating,
		duration:              durationMinutes * 60 * 1000,
		guid:                  show.GUID,
		genres:                show.Genres,
		studio:                show.Studio,
		bandwidth:             5000 + rng.Intn(15000),
		location:              locationTypes[rng.Intn(len(locationTypes))],
		sessionKey:            sessionKey,
		viewOffset:            watchedMinutes * 60 * 1000,
		percentComplete:       percentComplete,
		pausedCounter:         rng.Intn(3),
		transcodeDecision:     transcodeDecision,
		videoCodec:            videoCodec,
		videoBitrate:          6000 + rng.Intn(15000),
		videoResolution:       videoRes,
		videoFullResolution:   videoRes + "p",
		audioCodec:            audioCodec,
		audioChannels:         audioChannels[rng.Intn(len(audioChannels))],
		container:             containers[rng.Intn(len(containers))],
		bitrate:               8000 + rng.Intn(20000),
		videoDecision:         transcodeDecision,
		audioDecision:         "direct play",
		streamBitrate:         6000 + rng.Intn(12000),
		streamVideoCodec:      videoCodec,
		streamVideoResolution: videoRes,
		streamAudioCodec:      audioCodec,
		streamAudioChannels:   audioChannels[rng.Intn(len(audioChannels))],
	}
}

func generateTrackSession(musicArtists []MusicArtist, user User, sessionTime time.Time) sessionData {
	artist := musicArtists[rng.Intn(len(musicArtists))]
	album := artist.Albums[rng.Intn(len(artist.Albums))]
	track := album.Tracks[rng.Intn(len(album.Tracks))]

	durationSeconds := track.Duration
	watchedSeconds := rng.Intn(durationSeconds + 1)
	percentComplete := (watchedSeconds * 100) / durationSeconds
	if percentComplete > 100 {
		percentComplete = 100
	}

	started := sessionTime.Unix()
	stopped := sessionTime.Add(time.Duration(watchedSeconds) * time.Second).Unix()
	sessionKey := fmt.Sprintf("session-%s-%d", user.MachineID[:8], started)

	albumTitle := album.AlbumTitle
	artistName := artist.ArtistName
	fullTitle := fmt.Sprintf("%s - %s", artist.ArtistName, track.Title)

	return sessionData{
		started:              started,
		stopped:              stopped,
		ratingKey:            track.RatingKey,
		parentRatingKey:      &album.ParentRatingKey,
		grandparentRatingKey: &artist.GrandparentRatingKey,
		mediaType:            "track",
		title:                track.Title,
		parentTitle:          &albumTitle,
		grandparentTitle:     &artistName,
		fullTitle:            fullTitle,
		sectionID:            3,
		libraryName:          "Music",
		thumb:                fmt.Sprintf("/library/metadata/%s/thumb", album.ParentRatingKey),
		year:                 1970 + rng.Intn(54),
		duration:             durationSeconds * 1000,
		guid:                 fmt.Sprintf("plex://track/%s", generateGUID(track.RatingKey)),
		genres:               "Rock|Pop",
		bandwidth:            500 + rng.Intn(1500),
		location:             locationTypes[rng.Intn(len(locationTypes))],
		sessionKey:           sessionKey,
		viewOffset:           watchedSeconds * 1000,
		percentComplete:      percentComplete,
		transcodeDecision:    "direct play",
		audioCodec:           []string{"flac", "aac", "mp3"}[rng.Intn(3)],
		audioChannels:        "2",
		container:            "flac",
		bitrate:              800 + rng.Intn(600),
		audioDecision:        "direct play",
		streamBitrate:        800 + rng.Intn(600),
		streamAudioCodec:     "aac",
		streamAudioChannels:  "2",
	}
}

func verifyDatabase(t *testing.T, ctx context.Context, db *sql.DB, expectedSessions int) {
	t.Log("=== DATABASE VERIFICATION ===")

	// Count sessions
	var count int
	err := db.QueryRowContext(ctx, "SELECT COUNT(*) FROM tautulli.session_history").Scan(&count)
	if err != nil {
		t.Errorf("Failed to count sessions: %v", err)
		return
	}
	if count != expectedSessions {
		t.Errorf("Expected %d sessions, got %d", expectedSessions, count)
	} else {
		t.Logf("Session count: %d (expected: %d) - OK", count, expectedSessions)
	}

	// Count metadata
	err = db.QueryRowContext(ctx, "SELECT COUNT(*) FROM tautulli.session_history_metadata").Scan(&count)
	if err != nil {
		t.Errorf("Failed to count metadata: %v", err)
		return
	}
	if count != expectedSessions {
		t.Errorf("Expected %d metadata records, got %d", expectedSessions, count)
	} else {
		t.Logf("Metadata count: %d (expected: %d) - OK", count, expectedSessions)
	}

	// Count media info
	err = db.QueryRowContext(ctx, "SELECT COUNT(*) FROM tautulli.session_history_media_info").Scan(&count)
	if err != nil {
		t.Errorf("Failed to count media info: %v", err)
		return
	}
	if count != expectedSessions {
		t.Errorf("Expected %d media info records, got %d", expectedSessions, count)
	} else {
		t.Logf("Media info count: %d (expected: %d) - OK", count, expectedSessions)
	}

	// Count unique users
	var uniqueUsers int
	err = db.QueryRowContext(ctx, "SELECT COUNT(DISTINCT user_id) FROM tautulli.session_history").Scan(&uniqueUsers)
	if err != nil {
		t.Errorf("Failed to count unique users: %v", err)
		return
	}
	t.Logf("Unique users: %d (expected: %d)", uniqueUsers, numUsers)
	if uniqueUsers != numUsers {
		t.Errorf("Expected %d unique users, got %d", numUsers, uniqueUsers)
	}

	// Count by media type
	t.Log("Media type distribution:")
	rows, err := db.QueryContext(ctx, "SELECT media_type, COUNT(*) FROM tautulli.session_history GROUP BY media_type ORDER BY media_type")
	if err != nil {
		t.Errorf("Failed to count by media type: %v", err)
		return
	}
	defer rows.Close()

	for rows.Next() {
		var mediaType string
		var typeCount int
		if err := rows.Scan(&mediaType, &typeCount); err != nil {
			t.Errorf("Failed to scan media type: %v", err)
			continue
		}
		t.Logf("  %s: %d sessions", mediaType, typeCount)
	}

	// Verify static session key format (static-session-XXXX)
	var staticSessionCount int
	err = db.QueryRowContext(ctx, "SELECT COUNT(*) FROM tautulli.session_history WHERE session_key LIKE 'static-session-%'").Scan(&staticSessionCount)
	if err != nil {
		t.Errorf("Failed to count static sessions: %v", err)
		return
	}
	if staticSessionCount == expectedSessions {
		t.Logf("Session key format: %d/%d use 'static-session-XXXX' format - OK", staticSessionCount, expectedSessions)
	} else {
		t.Logf("Session key format: %d/%d use static format (legacy: %d)", staticSessionCount, expectedSessions, expectedSessions-staticSessionCount)
	}

	// Verify date range
	var minDate, maxDate int64
	err = db.QueryRowContext(ctx, "SELECT MIN(started), MAX(started) FROM tautulli.session_history").Scan(&minDate, &maxDate)
	if err != nil {
		t.Errorf("Failed to get date range: %v", err)
		return
	}
	minTime := time.Unix(minDate, 0).UTC()
	maxTime := time.Unix(maxDate, 0).UTC()
	t.Logf("Date range: %s to %s", minTime.Format("2006-01-02"), maxTime.Format("2006-01-02"))

	// Show sample session keys for debugging
	t.Log("Sample session keys (first 5):")
	sampleRows, err := db.QueryContext(ctx, "SELECT id, session_key FROM tautulli.session_history ORDER BY id LIMIT 5")
	if err != nil {
		t.Logf("  (could not retrieve samples: %v)", err)
	} else {
		defer sampleRows.Close()
		for sampleRows.Next() {
			var id int
			var sessionKey string
			if err := sampleRows.Scan(&id, &sessionKey); err != nil {
				continue
			}
			t.Logf("  ID %d: %s", id, sessionKey)
		}
	}

	t.Log("=== VERIFICATION COMPLETE ===")
}
